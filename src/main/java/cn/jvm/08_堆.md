# 08_堆

## 核心概述

1. 一个**JVM实例**只存在**一个堆**，堆是Java内存管理最大的一块核心区域。
2. Java堆区在JVM启动的候即被创建，其空间大小也就确定了，但可以在**创建前调整**大小。
3. 《Java虚拟机规范》规定，堆可以处于**物理上不连续**的内存空间，但**逻辑上连续**。
4. 所有的线程共享Java堆，堆还可以被划分为**线程私有缓冲区**（Thread Local Allocation Buffer, TLAB）。
5. 《Java虚拟机规范》中对Java堆的描述是

   * **从设计初衷来讲**所有的对象实例以及数组都应当在运行时分配到堆上。（The heap is the run-time data area from which memory for **~~all~~** class instances and arrays is allocated）

   * 从实际角度看，这里讲的应当是**几乎（almost）**，对象**可能**出现在栈上。

   * **从设计初衷来讲**，数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或数组**在堆中的位置**。
6. 方法结束后，堆中的对象**不会立即被移除**，仅在垃圾回收的时候才被移除。
7. **堆**是垃圾收集器（Garbage Collector）执行**垃圾回收的重点区域**。

## 年轻代与老年代

![JVM堆结构](ref/JVM堆结构.svg)

> 堆结构划分

* 存储在JVM中的Java对象可以被划分为两类：
  * **生命周期较短**的对象，创建和消亡非常迅速。
  * **生命周期很长**的对象，极端情况下可以与JVM生命周期保持一致。
* Java堆区进一步细分的话，可以划分为**年轻代（YoungGen）**和**老年代（OldGen）**
* 年轻代进一步细分为**伊甸园区(Eden)**，**幸存者0(Suvivor 0)**，**幸存者1(Suvivor 1)**

> 堆结构占比说明

* 新生代比例，默认**-XX:NewRatio=**2，代表**【新生代 : 老年代】 = 1 : 2**
* 幸存者比例，默认**-XX:SurvivorRatio=**8，代表**【幸存者0 : 幸存者1 : 伊甸园】 = 1 : 1 : 8**

> 补充

* 几乎所有Java对象都是在**伊甸园(Eden)**被new出来的。
* 绝大部分Java对象的销毁在**新生代(Young Gen)**进行。
  * IBM公司研究表明，新生代中80%的对象都是“朝生夕死”的。
* **-Xmn** 设置**新生代最大内存**大小。一般默认即可。

## 对象分配过程

### 重要性

1. 内存如何分配，在哪里分配。
2. **内存分配**与**垃圾回收**密切相关，回收后是否产生及如何处理产生**内存碎片**。

### 过程概述

1. new创建的对象放到**伊甸园区**，有大小限制。
2. 伊甸园区满，程序还需对象，则JVM对伊甸园区执行**垃圾回收(Minor GC)**，将不需要的对象销毁，再创建新的对象放伊甸园区。
3. 伊甸园区中的剩余对象移动到**幸存者0区(Survivor 0)**。
4. 再次触发垃圾回收，此时上次幸存下来的**幸存者0区(Survivor 0)**如果未被回收，放到**幸存者1区(Survivor 1)**。
5. 再次触发垃圾回收，重复3和4的过程。
6. 老年代，**默认15次**垃圾回收触发之后的存活对象。
   * **-XXMaxTenuringThreshold=\<N\>**，设置存活移动到老年代的垃圾回收次数。

![堆_对象分配过程](ref/堆_对象分配过程.svg)

### 小结

* 针对幸存者S0区和S1区：
  * 复制之后有交换，谁空谁是to；
* 关于垃圾回收，
  * **频繁**在**新生区**收集，
  * **很少**在**老年区**收集，
  * **几乎不**在**永久区/元空间**收集。

### 特殊情况补充

```flow
st=>start: 新对象申请
cond_eden=>condition: Eden放得下？
op_ram=>operation: 对象分配内存
op_ygc=>subroutine: YGC
st->cond_eden
cond_eden(yes)->op_ram
cond_eden(no)->op_ygc

cond_eden2=>condition: Eden放得下？
op_ygc->cond_eden2
cond_eden2(yes)->op_ram

cond_oldgen=>condition: Old放得下？
cond_eden2(no)->cond_oldgen

op_fgc=>operation: FGC
cond_oldgen(yes)->op_ram
cond_oldgen(no)->op_fgc

e=>end: OOM
cond_oldgen2=>condition: Old放得下？
op_fgc->cond_oldgen2
cond_oldgen2(yes)->op_ram
cond_oldgen2(no)->e
```

```flow
st=>start: 开始
cond_s=>condition: Survivor放得下？
op_s=>operation: 放置到S0/S1区域
cond_thres=>condition: 对象存活超过阈值？
end=>end: 晋升老年代

st->cond_s
cond_s(yes)->op_s
cond_s(no)->end
op_s->cond_thres
cond_thres(yes)->end
cond_thres(no)->op_s
```

