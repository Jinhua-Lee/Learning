# 09_方法区

## 一、栈、堆、方法区的交互关系

1. 从**线程共享与否**的角度

   ```mermaid
   graph TB
     memory(内存区域) --> thread_share>线程共享]
     memory --> thread_private>线程私有]
     thread_share --> thread_local(ThreadLocal)
     thread_local --> thread_private
    
     thread_share --> heap(堆)
     thread_share --> meta(元空间)
     heap --> oom_hep[OutOfMemoryError: Java heap space]
     meta --> oom_meta[OutOfMemoryError: Metaspace]
    
     overflow_stack[StackOverFlowError]
     thread_private --> java_stack(虚拟机栈) --> overflow_stack
     thread_private --> native_stack(本地方法栈) --> overflow_stack
     thread_private --> pc(程序计数器)
   ```

2. 举例

   ![栈、堆、方法区交互关系](ref/栈、堆、方法区交互关系.svg)

## 二、方法区的理解

### 1. 基本理解

1. **逻辑上**是堆的一部分；
2. 可选择**不进行垃圾回收或压缩**。
3. 与堆（Heap）一样，**线程共享**，可以**固定大小或可扩展**。
4. 在**JVM启动时**被创建，物理内存可以不连续，**逻辑上连续**。
5. 方法区大小决定了可以保存多少个类信息
   * 内存溢出类型：
     * OutOfMemoryError: PermGen space（JDK 7）
     * OutOfMemoryError: MetaSpace（JDK 8+）
   * 内存溢出举例：
     * 加载大量第三方jar包；
     * Tomcat部署过多工程。
     * 大量动态生成反射类。

## 三、方法区大小与OOM

### 1. 设置方法区内存大小

|              | JDK 7                               | JDK 8                                                        |
| ------------ | ----------------------------------- | ------------------------------------------------------------ |
| 初始内存     | **-XX:PermSize**                    | **-XX:MetaspaceSize**                                        |
|              | 默认20.75M                          | Windows默认21M                                               |
| 最大内存     | **-XX:MaxPermSize**                 | **-XX:MaxMetaspaceSize**                                     |
|              | 32位默认64M，64位默认82M            | Windows默认-1（无限制，但耗尽系统内存也会抛出OOM:Metaspace） |
| 内存溢出信息 | **OutOfMemoryError: PermGen space** | **OutOfMemoryError: Metaspace**                              |
|              |                                     |                                                              |

> 内存大小细节

1. 对**64位服务器JVM**而言，**初始内存默认21M是上限**。一旦超过该值，**Full GC**即会触发，**卸载无用类**（类对应的类加载器将不再存活），**重置上限**。
2. **新的上限值**取决于Full FC释放元空间的大小。
   * 释放空间**不足**，则在**不超过最大值的前提**下适当**提高**。
   * 释放空间**过多**，则**适当降低**。
3. **初始值过低**，则会发生**多次FullGC**（通过垃圾回收器日志可以观察到）。因此建议将初始值设置位一个**相对较高**的值，从而避免多次GC。

### 2. 如何解决这些OOM

一般手段是，首先通过**内存映像分析工具**（如Eclipse Memory Analyzer）对**dump出来的堆转储快照**进行分析，重点是确定内存中的**对象是否是必要**的，即区分**内存泄漏（Memory Leak）**与**内存溢出（Memory Overflow）**

| 异常类型                        | 概念说明                                                     | 处理方式                                                     |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 内存泄漏（**Memory Leak**）     | 申请的内存**大于系统能够提供**的内存，导致**无法申请足够**的内存 | 用工具查看泄漏对象**到GCRoot引用链**，定位到泄漏代码。       |
| 内存溢出（**Memory Overflow**） | 用完之后却没有被GC回收，**始终占用着内存**                   | 1. 检查**堆参数**-Xms -Xmx；<br>2. 代码检查是否存在**生命周期过长的对象**，进行优化。 |

## 四、方法区内部结构

### 1. 类型

包括**类class**、**接口interface**、**枚举enum**、**注解annotation**的类型

1. **全类名**（包名.类名）
2. **直接父类的全类名**（顶层interface和Object类除外）
3. **修饰符（权限public等、抽象abstract、final）**的某个子集
4. 该类型的**直接接口**的一个**有序列表**

### 2. 域（Field）

必须包含**域信息**，以及**多个域的声明顺序**

1. 名称（变量名）

2. 类型（class等）

3. 域修饰符（以下的某个**子集**）
   * 访问权限**public**
   * 静态**static**
   * 指向不变**final**
   * 禁止指令重排序**volatile**
   * 序列化**transient**

### 3. 方法（Method）

必须包含**方法的以下信息**，以及**多个方法的声明顺序**

1. 方法名
2. 返回类型（return）
3. 入参数量、类型、顺序
4. 方法修饰符（访问权限public）
   * 访问权限**public**
   * 静态**static**
   * 禁止重写**final**
   * 同步**synchronized**
   * 本地**native**
   * 抽象**abstract**
5. 方法字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native除外）
6. 异常表（abstract和native除外）
   * 每个异常处理的**开始位置**及**结束位置**；
   * 代码处理在**程序计数器中的偏移地址**。
   * 被捕获**异常的常量池索引**。

### 补充

#### 1. 变量初始化时机

1. 代码举例

```java
/**
 * 变量赋值的时机测试<p>&emsp;
 * 1) non-final变量测试<p>&emsp;
 * 2) static final变量测试
 *
 * @author Jinhua
 * @date 2021/4/14 22:40
 */
@SuppressWarnings("all")
public class ValueAssignTest {

    public static void main(String[] args) {
        Order order = null;
        // 类的实例为null，仍然可以访问
        order.hello();
        System.out.println(order.count);
        System.out.println(order.NUMBER);
    }
}

class Order {
    /**
     * 【链接 -> 准备】阶段仅默认赋值（0值）
     * 【初始化】过程 执行class对象构造，<clinit>显式赋值为1
     */
    public static int count = 1;

    /**
     * 类加载过程中，【链接 -> 准备】阶段已经显式赋值
     */
    public static final int NUMBER = 2;

    public static void hello() {
        System.out.println("hello");
    }
}
```

2. 编译结果

![类变量的赋值时机](ref/类变量的赋值时机.png)

3. 小结

   | 变量类型                    | 赋值时机                                                     |
   | --------------------------- | ------------------------------------------------------------ |
   | **non-final变量（static）** | 1. 【链接 -> **准备**】阶段仅**默认赋值**（0值，引用类型null）<br>2. 【**初始化**】过程 执行class对象构造，\<clinit\>**显式赋值** |
   | **static final变量**        | 类加载过程中，【链接 -> 准备】阶段**直接显式赋值**           |

### 4. **常量池**与**运行时常量池**

> **整体关系**

* **字节码**文件 ==> 内部包含**常量池**；
* **方法区** ==> 内部包含**运行时常量池**；
* 要弄清楚方法区，需要理解字节码文件，因为类的信息都加载到方法区。
* 要弄清楚方法区的运行时常量池，需要理解清楚字节码中的常量池。

#### 1. 常量池的概述

1. 包含信息
   * **类的版本**、**字段**、**方法**、**接口**等描述信息
   * **常量池表**
     * 各种字面量
     * 对类型、域、方法的符号引用。

2. 常量池在字节码文件中的位置

![常量池在字节码文件中的位置](ref/常量池在字节码文件中的位置.png)

3. 为什么需要运行时常量池？

   代码举例如下：

   ```java
   public class SimpleClass {
       public void sayHello {
           System.out.println("hello");
       }
   }
   ```

   * **用到的信息远不止那么多**，虽然该类编译出的类信息很少（194 byte），但里面用到的信息却很多，比如String，System，PrintStream，Object等结构
   * 用常量池作符号引用，在类加载过程【**链接 -> 解析**】时候，将**符号引用转换为直接引用**。

4. 常量池具体内容

   1. 数据类型
      * 数量值
      * 字符串值
      * 类引用
      * 字段引用
      * 方法引用

   例如，以下代码

   ```java
   public class MethodAreaTest2 {
       public static void main(String[] args) {
           Object obj = new Object();
       }
   }
   ```

   第三行 Object obj = new Object();会被编译为

   ```java
   0:		new #2		// Class java/lang/Object
   1:		dup
   2:		invokespecial	#3		// Method java/lang/Object	"<init>"()	V
   ```
   
5. 常量池小结

   **可以看作一张表**，虚拟机指令根据这张表找到要执行的类名、方法名、参数类型、字面量等类型。

#### 2. 运行时常量池概述



## 五、方法区使用举例

## 六、方法区的演进

### 1. 名称演进

* JDK 7之前： **永久代**。
* JDK 8之后：**元空间**。

最大区别是，**元空间**不在虚拟机设置的内存中，而**使用本地内存**。

### 2. 名词归属关系

**永久代或元空间**，可以看作是**方法区的实现**。

* 方法区和永久代，**对于Hotspot虚拟机而言才等价**。对于JRockit / J9虚拟机而言，不存在永久代的概念。
  * 现在看来，当年使用**永久代**不是好的主意，容易导致程序OOM（**超过MaxPermSize上限**）

## 七、方法区的垃圾回收

## 八、小结