# 09_方法区

## 一、栈、堆、方法区的交互关系

1. 从**线程共享与否**的角度

   ```mermaid
   graph TB
     memory(内存区域) --> thread_share>线程共享]
     memory --> thread_private>线程私有]
     thread_share --> thread_local(ThreadLocal)
     thread_local --> thread_private
    
     thread_share --> heap(堆)
     thread_share --> meta(元空间)
     heap --> oom_hep[OutOfMemoryError: Java heap space]
     meta --> oom_meta[OutOfMemoryError: Metaspace]
    
     overflow_stack[StackOverFlowError]
     thread_private --> java_stack(虚拟机栈) --> overflow_stack
     thread_private --> native_stack(本地方法栈) --> overflow_stack
     thread_private --> pc(程序计数器)
   ```

2. 举例

   ![栈、堆、方法区交互关系](ref/栈、堆、方法区交互关系.svg)

## 二、方法区的理解

1. **逻辑上**是堆的一部分；
2. 可选择**不进行垃圾回收或压缩**。
3. 与堆（Heap）一样，**线程共享**，可以**固定大小或可扩展**。
4. 在**JVM启动时**被创建，物理内存可以不连续，**逻辑上连续**。
5. 方法区大小决定了可以保存多少个类信息
   * 内存溢出类型：
     * OutOfMemoryError: PermGen space（JDK 1.7）
     * OutOfMemoryError: MetaSpace（JDK 1.8+）
   * 内存溢出举例：
     * 加载大量第三方jar包；
     * Tomcat部署过多工程。
     * 大量动态生成反射类。

## 三、方法区大小与OOM

## 四、方法区内部结构

## 五、方法区使用举例

## 六、方法区的演进

## 七、方法区的垃圾回收

## 八、小结