# 09_方法区

## 一、栈、堆、方法区的交互关系

1. 从**线程共享与否**的角度

   ```mermaid
   graph TB
     memory(内存区域) --> thread_share>线程共享]
     memory --> thread_private>线程私有]
     thread_share --> thread_local(ThreadLocal)
     thread_local --> thread_private
    
     thread_share --> heap(堆)
     thread_share --> meta(元空间)
     heap --> oom_hep[OutOfMemoryError: Java heap space]
     meta --> oom_meta[OutOfMemoryError: Metaspace]
    
     overflow_stack[StackOverFlowError]
     thread_private --> java_stack(虚拟机栈) --> overflow_stack
     thread_private --> native_stack(本地方法栈) --> overflow_stack
     thread_private --> pc(程序计数器)
   ```

2. 举例

   ![栈、堆、方法区交互关系](ref/栈、堆、方法区交互关系.svg)

## 二、方法区的理解

### 1. 基本理解

1. **逻辑上**是堆的一部分；
2. 可选择**不进行垃圾回收或压缩**。
3. 与堆（Heap）一样，**线程共享**，可以**固定大小或可扩展**。
4. 在**JVM启动时**被创建，物理内存可以不连续，**逻辑上连续**。
5. 方法区大小决定了可以保存多少个类信息
   * 内存溢出类型：
     * OutOfMemoryError: PermGen space（JDK 7）
     * OutOfMemoryError: MetaSpace（JDK 8+）
   * 内存溢出举例：
     * 加载大量第三方jar包；
     * Tomcat部署过多工程。
     * 大量动态生成反射类。

## 三、方法区大小与OOM

### 1. 设置方法区内存大小

|              | JDK 7                               | JDK 8                                                        |
| ------------ | ----------------------------------- | ------------------------------------------------------------ |
| 初始内存     | **-XX:PermSize**                    | **-XX:MetaspaceSize**                                        |
|              | 默认20.75M                          | Windows默认21M                                               |
| 最大内存     | **-XX:MaxPermSize**                 | **-XX:MaxMetaspaceSize**                                     |
|              | 32位默认64M，64位默认82M            | Windows默认-1（无限制，但耗尽系统内存也会抛出OOM:Metaspace） |
| 内存溢出信息 | **OutOfMemoryError: PermGen space** | **OutOfMemoryError: Metaspace**                              |
|              |                                     |                                                              |

> 内存大小细节

1. 对**64位服务器JVM**而言，**初始内存默认21M是上限**。一旦超过该值，**Full GC**即会触发，**卸载无用类**（类对应的类加载器将不再存活），**重置上限**。
2. **新的上限值**取决于Full FC释放元空间的大小。
   * 释放空间**不足**，则在**不超过最大值的前提**下适当**提高**。
   * 释放空间**过多**，则**适当降低**。
3. **初始值过低**，则会发生**多次FullGC**（通过垃圾回收器日志可以观察到）。因此建议将初始值设置位一个**相对较高**的值，从而避免多次GC。

### 2. 如何解决这些OOM

一般手段是，首先通过**内存映像分析工具**（如Eclipse Memory Analyzer）对**dump出来的堆转储快照**进行分析，重点是确定内存中的**对象是否是必要**的，即区分**内存泄漏（Memory Leak）**与**内存溢出（Memory Overflow）**

| 异常类型                        | 概念说明                                                     | 处理方式                                                     |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 内存泄漏（**Memory Leak**）     | 申请的内存**大于系统能够提供**的内存，导致**无法申请足够**的内存 | 用工具查看泄漏对象**到GCRoot引用链**，定位到泄漏代码。       |
| 内存溢出（**Memory Overflow**） | 用完之后却没有被GC回收，**始终占用着内存**                   | 1. 检查**堆参数**-Xms -Xmx；<br>2. 代码检查是否存在**生命周期过长的对象**，进行优化。 |

## 四、方法区内部结构

### 1. 类型

包括**类class**、**接口interface**、**枚举enum**、**注解annotation**的类型

1. **全类名**（包名.类名）
2. **直接父类的全类名**（顶层interface和Object类除外）
3. **修饰符（权限public等、抽象abstract、final）**的某个子集
4. 该类型的**直接接口**的一个**有序列表**

### 2. 域（Field）

必须包含**域信息**，以及**多个域的声明顺序**

1. 名称（变量名）

2. 类型（class等）

3. 域修饰符（以下的某个**子集**）
   * 访问权限**public**
   * 静态**static**
   * 指向不变**final**
   * 禁止指令重排序**volatile**
   * 序列化**transient**

### 3. 方法（Method）

必须包含**方法的以下信息**，以及**多个方法的声明顺序**

1. 方法名
2. 返回类型（return）
3. 入参数量、类型、顺序
4. 方法修饰符（访问权限public）
   * 访问权限**public**
   * 静态**static**
   * 禁止重写**final**
   * 同步**synchronized**
   * 本地**native**
   * 抽象**abstract**
5. 方法字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native除外）
6. 异常表（abstract和native除外）
   * 每个异常处理的**开始位置**及**结束位置**；
   * 代码处理在**程序计数器中的偏移地址**。
   * 被捕获**异常的常量池索引**。

## 五、方法区使用举例

## 六、方法区的演进

### 1. 名称演进

* JDK 7之前： **永久代**。
* JDK 8之后：**元空间**。

最大区别是，**元空间**不在虚拟机设置的内存中，而**使用本地内存**。

### 2. 名词归属关系

**永久代或元空间**，可以看作是**方法区的实现**。

* 方法区和永久代，**对于Hotspot虚拟机而言才等价**。对于JRockit / J9虚拟机而言，不存在永久代的概念。
  * 现在看来，当年使用**永久代**不是好的主意，容易导致程序OOM（**超过MaxPermSize上限**）

## 七、方法区的垃圾回收

## 八、小结