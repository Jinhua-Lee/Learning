# 15_垃圾回收相关算法

> 对象存活判断

当一个对象不再被**任何已存活的对象**引用时，对象被视为已死亡。

## 一、标记阶段：引用计数算法

### 1. 思路概述

* 每个对象保存一个**整形的引用计数器**属性。

  * 对A对象**增加引用**时，将A的引用计数器**值+1**；
  * **引用失效**时，引用计数器**值-1**；
  * 当对象引用**计数器值为0**时，表示对象A不可能再被使用，**可进行回收**。

### 2. 优势

1. 实现简单，垃圾对象便于辨识；
2. 判定效率高，回收没有延迟性。

### 3. 劣势

1. 存储空间开销
   * 需要单独的**字段存储计数器值**。

2. 时间开销
   * 每次赋值都需要**更新计数器**，伴随加法和减法操作。
   
3. **无法处理循环引用**

   * Java中有循环引用的情况，该算法无法解决，所以没有采用该算法。
   * 补充：Python解决循环依赖方案。
     * 手动解除：合适的时机，将引用计数器手动置为0；
     * 弱引用（weakref）：Python提供标准库。
   * 举例：**单循环链表**。

   ```java
   /**
    * 循环引用问题探究<p>&emsp;
    * -XX:+PrintGCDetails <p><p>
    * 操作：打开或关闭{@link System#gc()} 方法；<p>
    * 结果：GC信息，内存占用不同；<p>
    * 结论：Java未使用引用计数算法；<p>
    *
    * @author Jinhua
    * @version 1.0
    * @date 2021/4/29 21:04
    */
   public class RefCountGc {
       /**
        * 唯一作用：占内存
        */
       private final byte[] bigSize = new byte[5 * 2024 * 1024];
   
       RefCountGc reference = null;
   
       public static void main(String[] args) {
           RefCountGc r1 = new RefCountGc();
           RefCountGc r2 = new RefCountGc();
   
           // 互相引用
           r1.reference = r2;
           r2.reference = r1;
           // 释放外部引用
           r1 = null;
           r2 = null;
           // 打开或关闭gc方法，观察是否会执行GC
           System.gc();
       }
   }
   ```

## 二、标记阶段：可达性分析算法

### 1. 别名

* 根搜索算法
* 追踪性垃圾收集

### 2. 特点

* 简单高效**；

* 有效**解决循环引用**问题，防止内存泄漏。

### 3. 根对象集合（GC Roots）

#### 1) 约束定义

* 一组**必须活跃的引用**。

#### 2) 主要GC Roots

1. **虚拟机栈（Java Stack）**中的引用对象。
2. **本地方法栈（Native Method Stack）**内的**JNI引用**的对象。

3. 方法区**静态属性**引用的对象。
4. 被同步锁**synchronized**持有的对象。
5. **JVM内部的引用**。
   * 基本数据类型对应的Class对象。
   * 常驻的异常对象。
   * 系统类加载器。
6. 反映**JVM内部情况的对象**。如JMXBean，JVMIT中注册的回调，本地代码缓存等。

#### 3) 其他GC Roots

除了上述固定的GC Roots外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，其他对象引用可临时加入GC Roots。比如**分代收集**和**局部回收（Partial GC）**。

* 如果只针对堆空间某一块区域GC（比如Young区），必须考虑内存区域是虚拟机是自己的实现细节，而不是内存封闭的，**这个区域的对象可能被其他区域的对象所引用**，必须将关联区域的对象一并加入GC Roots集合中。

#### 4) 小技巧

Root采用栈方式存放变量和指针， 如果是一个指针，**保存了堆内存里面的对象，自己又不在堆内存**，则它应该被包含于GC Roots。

### 4. 思路概述

1. 以**根对象集合（GC Roots）**为起始点，按**自顶向下方法搜索**所连接目标**是否可达**。
2. 经过可达性分析后，**存活对象**都会被**根对象直接或间接关联**，搜索走过的路径称为**引用链（Reference Chain）**。
3. 目标对象**没有任何引用链相连**，则是不可达的，意味着对象已经死亡可被回收。

### 5. 一致性

* 分析工作中需要保证**引用关系在一个快照中进行**，才能保证分析结果准确性。
* 所以，GC进行时会**停止用户线程**，以保证一致性。
  * 即使是号称几乎不发生停顿的CMS收集器，枚举根节点也是必须要停顿的。

## 三、对象的finalization机制

## 四、MAT与JProfiler的GC Roots溯源

## 五、清除阶段：标记-清除算法

## 六、清除阶段：复制算法

## 七、清除阶段：标记-压缩算法

## 八、清除算法小结

## 九、分代收集算法

## 十、增量收集算法、分区算法