# 05_运行时数据区(Runtime Area)

## 概述

> 内存

- **内存**是非常重要的系统资源，是硬盘和CPU的**中间仓库及桥梁**，承载着操作系统和应用程序的实时运行。
- **JVM内存布局**规定了Java程序在运行过程中**内存申请**、**分配**、**管理**的策略，保证了JVM的高效、稳定运行。
- **不同JVM**对内存划分方式和管理机制**存在差异**。比如JRockit和J9虚拟机无Method Area（方法区）。

> HotSpot JVM **运行时数据区**

![HotSpot JVM 运行时数据区](ref/HotSpot_JVM_运行时数据区.png)

![HotSpot JVM 运行时数据区\_2](ref/HotSpot_JVM_运行时数据区_2.png)

1. **方法区（Method Area）**和**堆（Heap）**线程共享

   * 方法区 => 元数据 + JIT编译产物
   * 堆 => 主要是对象

   关于线程共享的说明 => 每一个JVM只有一个java.lang.Runtime（运行时）对象

2. **虚拟机栈（Java Stack）**、**程序计数寄存器（Program Counter Register）**和**本地方法栈（Native Method Stack）**线程独享。

   * 生命周期**与线程一致**，随线程创建而创建，随线程销毁而消亡。

## 程序寄存计数器(Program Counter Register)

### 概述

1. Register命名来源于CPU的寄存器，**存储指令相关**的现场信息，CPU只有把数据装载到寄存器才能运行。

2. JVM中的Program Counter Register是对物理PC寄存器的一种**抽象的模拟**，或许翻译为**PC计数器**更贴切。

3. 是一块很小的，在内存中**运行速度最快**的内存空间，几乎可以忽略不记。

4. 每一个线程有一个PC程序计数器（**线程私有**），生命周期与线程一致。

5. **任何时间**，**一个线程**都只有**一个方法**在执行，即所谓的**当前方法**。

   * 程序计数器会存储**当前线程正在执行的方法**的JVM**指令地址**。
   * 如果执行的是**native方法**，则是**未指定值（undefined）**。

6. 它是程序**控制流指示器**，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖PC程序计数器完成。

7. 字节码解释器工作时，就是通过**改变计数器值**来**选取下一条**需要执行的字节码指令。

8. JVM规范中唯一一个**没有OutOfMemoryError**的区域。

   | 内存区域               | 是否有GC（垃圾回收） | 是否有OOM（内存溢出） |
   | ---------------------- | -------------------- | --------------------- |
   | Java Stack（虚拟机栈） | 否                   | 是                    |
   | Heap（堆）             | 是                   | 是                    |
   | Method Area（方法区）  | 是                   | 是                    |
   | PC寄存器               | 否                   | 否                    |

### 工作流程

#### 作用描述

![PC寄存器作用描述](ref/PC寄存器作用描述.png)

#### 工作原理示例

![PC寄存器工作示例](ref/PC寄存器工作示例.png)

#### 面试中两个常见问题

1. 使用PC寄存器**存储字节码指令地址**有什么用？为什么使用PC寄存器记录**当前线程的执行地址**呢？

   ![执行引擎切换线程](ref/执行引擎切换线程.png)

   * CPU需要**不停切换线程**，当切换回来的时候，就得知道**接着从哪个指令开始**执行。
   * JVM的字节码解释器就是通过改变PC寄存器**所存的字节码指令地址**的值来明确下一条该执行的指令。

2. 为什么PC寄存器为什么被设定为**每个线程独有一份**？

   * 记录**每个线程**正在执行的**当前字节码指令地址**，最好的办法是每个线程一份。这样各个线程直接可以进行**独立计算**， **不会互相干扰**。

## 虚拟机栈（Java Stack）

![虚拟机栈简图](ref/虚拟机栈简图.png)

### Java栈 概述

#### 指令集 ==> **零地址指令**

由于跨平台的设计，Java指令集都是根据**栈结构**来设计。不同平台的**CPU架构不同**，所以**不能基于寄存器**架构设计。

* **零地址指令**

  * 优势：
    * 跨平台
    * 指令集小
    * 编译器容易实现
  * 劣势：性能下降，实现同样的功能需要更多的指令。

#### 生命周期 ==> **与线程一致**

* 每个线程创建时都会创建一个虚拟机栈（Java Virtual Machine Stack），其内部保存一个个栈帧（Stack Frame），**入栈和出栈**对应着一次次**Java方法的调用。**
* Java栈是**线程私有**的。

#### 职责概述

1. 作用

   - 主管Java程序的运行，它保存方法的**局部变量**（8种**基本数据类型的值**、对象的**引用地址**）、**部分结果**，并参与方法调用和返回。

2. 优势

   - **快速有效**的分配存储的方式，访问速度仅次于程序计数器；

   - JVM堆Java虚拟机栈的**操作简单**，只有两个：

   - - 每个方法的执行，入栈（push）；
     - 方法执行完，出栈（pop）；

   - **不存在垃圾回收**

   - - GC；
     - OOM：存在，一直压栈导致栈溢出。StackOverflowError；

3. 可能出现的异常 ==> Java虚拟机规范允许Java栈的大小是**动态**或者**固定不变**的。

   * 可能存在OOM
   
     - 虚拟机栈**大小动态扩展**，在尝试扩展时候无法申请到足够内存；
     - 创建线程时候**没有足够内存**去创建对应的虚拟机栈。
   
   * 可能存在栈溢出
   
     ```java
     public class StackErrorTest {
     
         private static int count = 1;
     
         public static void main(String[] args) {
     
             /*
              * 1. 默认情况，count = 5885 时候抛异常；
              * 2. 设置栈大小，Xss = 256k时，count = 1928 时候抛异常
              */
             System.out.println("count = " + count++);
             main(args);
         }
     }
     ```
   

#### 运行过程

1. 存储单位 ==> **栈帧**
2. 运行原理
3. 内部结构 
   - 局部变量表（Local Variables）
   - 操作数栈（Operand Stack）（或表达式栈）
   - 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
   - 方法返回地址（Return Address）（或方法正常退出或异常退出的定义）
   - 附加信息

### 局部变量表（Local Variables）

1. 别名

   * 局部变量数组
   * 本地变量表
   
2. 结构解析
    ![Java栈_局部变量表结构解析](ref/Java栈_局部变量表结构解析.png)

    * LineNumberTable ==> **代码开始行号**与**字节码开始行号**对应表

      * **start PC**：字节码开始行号
      * **Line Number**：代码开始行号

    * LocalVariable ==> **局部变量**的描述信息

      | **变量名** | **中文含义**| **说明**|
      | --------- | ---------- | -------- |
      | 开始start  | 字节码开始行号 |  |
      | length | 变量的字节码作用行长度 |  |
      | name       | 变量名 |  |
      | Signature  | 变量描述 | 开头 [ 代表数组     L 代表引用类型 |
    
3. 局部变量表的理解

    1. 定义为一个数字数组，主要存储**方法参数**和定义在**方法内的局部变量**；
        - 8种**基本数据类型**；
        - 对象的**引用**
        - **returnAddress类型**
    2. 局部变量表建立在**线程独立**的栈的栈帧上，线程私有，**不存在数据安全问题**。
    3. 局部变量表的所需容量大小在**编译期间确定**。保存在方法的Code属性的maxium local variables数据项中。局部变量表在**运行期间大小不变**。
    4. **方法嵌套**调用的最大次数由**栈的大小**决定。
    5. 局部变量表中的**变量只在当前方法调用中有效**。调用结束后局部变量表会随着栈帧的销毁（出栈）而销毁。

4. 关于槽（slot）的理解

    1. 局部变量表中，**最基本的单元**Slot
    2. 参数值的存放总是在局部变量数组，索引范围 [0, length -1]
    3. 存放编译期可知的变量。
    4. 数据占用情况
        1. **32位以内**的类型（byte, short, int, char, boolean）**占用一个slot**
            * byte, short, char在存储前被转为int
            * boolean也被转位int，0表示false，非0表示true
        2. 64位类型（double, long）占用**两个slot**
    5. JVM会为局部变量表中的每一个Slot分配一个**访问索引**，通过索引访问变量值；
    6. **实例方法被调用**，方法参数和方法体内部变量都会**按定义顺序**被复制到变量表的每一个Slot
    7. 访问占**两个slot的64位的数据**（double, long）时，**使用起始索引**
    8. 如果当前栈帧由**构造方法或者实例方法**创建，则局部变量表的**index = 0 的位置**存放**当前对象的引用（this）**
        * **静态方法中不能使用this** -> this不存在于静态方法的局部变量表中。
    9. Slot是可以**重复利用**的。如果一个**局部变量过了其作用域**，那么在其作用域之后声明的局部变量就**可能复用过期的局部变量的Slot**，节省资源。

5. 变量分类

    1. 按数据类型

        * 基本数据类型
        * 引用数据类型

    2. 按在类中声明位置

        1. 成员变量

            1. 类变量 / 静态变量（static）

                - **Linking（链接）**的**Prepare（准备）**阶段，**默认赋值**
                - **Initialization（初始化阶段**），进行**静态代码块赋值**（若有静态代码块），或**显式赋值**。

            2. 实例变量

                对象创建，会在**堆空间**中分配实例变量空间，并进行**默认赋值**。

        2. 局部变量

            使用前，必须显式赋值，否则编译不通过。

            ```java
            int b;
            b+=2;
            ```

6. 小结

    - **栈帧性能调优**关系最为密切的部分就是局部变量表。方法执行时，虚拟机使用**局部变量表完成方法的传递**。
    - 局部变量表中的**变量也是重要的垃圾回收根节点**，只要被局部变量表中**直接或者间接引用的对象**都不会被回收。

### 操作数栈（Operand Stack）

### 动态链接（Dynamic Linking）

### 方法返回地址（Return Address）