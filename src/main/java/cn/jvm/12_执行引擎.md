# 12_执行引擎

## 一、概述

### 1. 地位

   * Java虚拟机**核心组成**部分之一。

### 2. 虚拟机与物理机

   * 【虚拟机】是一个相对于【物理机】的概念，两种机器都有代码执行的能力。

     * 【物理机】的执行引擎，**直接建立于**处理器、缓存、指令集和操作系统层面。
     * 【虚拟机】的执行引擎**由虚拟机程序实现**。可以**不受物理条件制约**地定制指令集与执行引擎结构体系，能执行哪些**不被硬件直接支持的指令集**格式。

### 3. 主要职责

* 将字节码指令解释 / 编译为平台上的本地机器指令。

## 二、Java代码编译和执行过程

![程序编译和执行过程](ref/程序编译和执行过程.svg)

### 1. 解释器与JIT编译器

### 1) 解释器

* Java虚拟机中，对字节码采取**逐行解释**，**翻译**为平台机器指令**并执行**的软件模块。

### 2) JIT编译器(Just In Time Compiler)

* 将字节码**编译**为本地**平台相关的机器语言**的软件模块。

### 2. 半编译半解释型语言

* JDK 1.0时代，Java语言定位为**解释执行**的语言。
* 目前的JVM执行Java代码，将**解释执行**和**编译执行**结合起来。

## 三、机器码、指令、汇编语言

![语言编译过程](ref/语言编译过程.svg)

### 1. 机器码

* 采用**二进制方式编码**的指令。
* 与CPU硬件紧密相关。
* 与其他类型语言相比，执行速度最快。
* 容易出错，不利于理解和记忆。

### 2. 指令与指令集

#### 1) 指令

* 基于机器码**可读性差的优化**。

* 0和1的不同**序列简化**为指令，如mov、inc等。
* **不同的硬件平台可能不同**。

#### 2) 指令集

* **不同硬件平台**，各自支持的指令有差别。区分为平台指令集。
  * **x86指令集**，对应x86架构平台。
  * **ARM指令集**，对应ARM架构平台。

### 3. 汇编语言

* 基于**指令可读性差的优化**发明。
* 汇编语言中，用**助记符(Mnemonic)**代替机器指令操作码，用**地址符号(symbol)**或**标号(Label)**代替指令或操作数地址。
* **平台 相关性**。在不同硬件平台的汇编语言对应不同的机器语言指令集。

### 4. 字节码

#### 1) 概述

* 一种**中间状态的二进制代码**，比机器码更抽象。需要直译器转译后才能成为机器码。

#### 2) 目的

* 为了实现**特定软件环境和软件运行**，与硬件无关。

#### 3) 实现

通过前端编译器（字节码编译器）和虚拟机器（如JVM）。

* 前端编译器：编译为字节码。
* 虚拟机器： 转译为可以直接执行的指令。

典型应用是**Java bytecode**。

## 四、解释器

### 1. 分类

#### 1)  字节码解释器

   * 纯软件代码模拟字节码执行，效率低下。
#### 2) 模板解释器

   * 每一条字节码**和一个模板函数关联**，模板函数**直接产生**该字节码执行时的机器码，很大程度上提高解释器性能。

### 2. Hotspot VM中的解释器

主要是Interpretor + Code两个模块构成。

#### 1) Interpretor模块

解释器**核心功能**。

#### 2) Code模块

**管理**运行时生成的**机器指令**。

### 3. 现状

* 解释器**实现非常简单**。Java，Perl，Python，Ruby都依赖于解释器。
* **低效**的代名词。
* JVM平台提出**JIT即时编译器**，优化低效的问题。
* 为中间语言的发展做出了贡献。

## 五、JIT编译器

Java程序运行性能已经**脱胎换骨**，能达到和C，C++一较高下的地步。

### 1. Hotspot VM为什么考虑解释器与JIT编译器并存的架构？

#### 1) 概括说明

互相协作，**取长补短**，尽力去选择最合适的方式来**权衡**编译本地代码的时间和直接翻译执行本地代码的时间。

1. 响应速度快：
   * 程序启动后，**解释器**可**立马发挥作用**，省去编译时间。
   * 而**编译器**必须把字节码编译为本地代码，**需要一定的执行时间**。编译完成后才是执行快的时候。
2. 场景权衡。
   * JRockit执行性能会非常高效，但**启动时**候必然**花费更长时间**。
   * 对于看重启动时间的应用场景而言，**解释器与编译器并存**的架构换取**平衡点**。
   * 解释执行在**编译器激进优化不成立**时，**解释器**作为编译器的**逃生门**。

#### 2) 案例——阿里团队

1. 概括说明
   * 解释器与编译器在执行线上环境微妙的辩证关系：
     * 机器在**热机状态能承受的负载要大于冷机状态**。
   * 生产环境发布过程中，以分批的方式进行发布，根据机器数划分为多个批次，每个批次机器数之多占到整个集群的 1 / 8。

2. 案例详情

   ​		某位程序员在发布平台进行分批发布，在输入发布总批数时，**误填写成分两批发布**。

   ​		如果是热机状态，正常情况下一般机器勉强可以承载流量，但由于**刚启动的JVM均是解释执行，还未进行热点代码统计和JIT动态编译**，当前发布成功的服务器马上宕机。

   ​		此故障某种程度上说明了JIT的存在。

### 2. JIT编译器

#### 1) 编译器的三种可能解释

1. 前端编译器
   * java文件 => class文件
2. 后端运行期编译器（JIT编译器）
   * 字节码文件 => 机器码
3. 静态提前编译器(Ahead Of Time Compiler)
   * .java文件 => 机器码

#### 2) 热点代码及探测方式

1. **热点代码**

   * 是否需要JIT编译，取决于**代码被调用执行的频率**。
   * 频繁被调用的【**热点代码**】，被**直接编译**为本地平台**机器指令**，以此提升Java程序的性能。
   * 发生在**方法执行过程中**，因此也被称为**栈上替换(OSR, On Stack Replacement)**

2. **基于计数器的热点探测**。

   JVM为每一个方法建立两个不同类型的计数器：

   * 方法调用计数器（Invocation Counter）

     统计**被调用次数**，

     * VM参数-XX:CompileThreshold

     * Client模式：默认1500次

     * Server模式：默认10000次

   * 回边计数器（Back Edge Counter）

     统计循环体内的**循环次数**

3. 方法调用计数器 ==> 热点代码**编译判断**

   ```mermaid
   graph TD
   	method(Java 方法入口) --> | 方法调用 | compiled{已编译?}
   
	compiled --> | 是 | mechain_code(机器码)
   	mechain_code --> method_return(方法返回)
   	method_return --> jit_final(即时编译结束)
   
   	compiled --> | 否 | invoke_counter(方法调用计数器 +1)
   	invoke_counter --> threshold_exceeded{计数器超过阈值?}
   	threshold_exceeded --> | 是 | compile_req(提交编译请求)
   	compile_req --> jit[JIT编译器]
   	jit --> backstage_compile(后台执行编译)
   	backstage_compile --> code_cache(方法区缓存机器码)
   	code_cache --> mechain_code
   	
   	threshold_exceeded --> | 否 | interpreter[解释器]
   	interpreter --> interpret(解释方式执行)
   	interpret --> method_return
   ```
   
4. 方法调用计数器 ==> **热度衰减**

   * 不做任何设置，方法调用计数器的统计的是**一段时间内方法被调用的次数**。
   * 当超过一定的时间限度，仍未达到**编译判断阈值**，则该统计值**减小一半**，即热度的**衰减（Counter Decay）**。这段时间即称为**半衰周期（Counter Half Life Time）**。
   * 半衰周期伴随GC过程进行。
     * 热度衰减开关：**-XX:-UseCounterDecay**
     * 半衰周期参数：**-XX:CounterHalfListTime**

5. 回边计数器

   * 统计一个方法中循环体代码执行次数。

   * 字节码中遇到控制流向后跳的指令称为回边。建立回边计数器的目的是为了触发OSR编译。

   ```mermaid
   graph TD
   	back_edge_instruction(遇到回边指令) --> compiled{是否存在已编译版本?}
   	compiled --> | 是 | execute_compiled(执行编译的本地代码)
   	execute_compiled --> method_return(Java 方法返回)
   	
   	compiled --> | 否 | back_edge_plus(回边计数器 +1)
   	back_edge_plus --> sum_over_threshold(两计数器之和超过阈值?)
   	sum_over_threshold --> | 否 | interpret(解释执行)
   	interpret --> method_return
   	
   	sum_over_threshold --> | 是 | req_osr(向编译器请求OSR编译)
   	req_osr --> back_edge_reset(调整回边计数器值)
   	back_edge_reset --> interpret
   ```

   