# 16_垃圾回收相关概念

## 一、System.gc()方法理解

### 1. 实现

```java
public final class System {
    public static void gc() {
        Runtime.getRuntime().gc();
    }
}
```

### 2. 使用

* 该方法**提醒JVM执行**GC，无法保证对垃圾收集器的调用。
* 一般不用手动调用。对于特殊场景，比如正在编写一个性能基准，可以手动调用。

```java
/**
 * {@link System#gc()}方法测试
 *
 * @author Jinhua
 * @date 2021/5/1 21:18
 */
public class SystemGc {

    public static void main(String[] args) {
        new SystemGc();
        // 提醒JVM执行gc方法
        System.gc();
        // 加上该方法，一定会执行gc
//        System.runFinalization();
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("重写了finalize方法");
    }
}
```

### 3. 对局部变量调用GC的理解

```java
/**
 * 局部变量的gc：观察buf数组的空间回收情况<p>
 * VM参数：<p>&emsp;
 * -XX:+PrintGCDetails
 *
 * @author Jinhua
 * @date 2021/5/1 21:50
 */
public class LocalVarGc {

    public static void main(String[] args) {
        LocalVarGc gc = new LocalVarGc();
        gc.gc1();
//        gc.gc2();
//        gc.gc3();
//        gc.gc4();
//        gc.gc5();
    }

    public void gc1() {
        byte[] buf = new byte[10 * 1024 * 1024];
        // 不执行GC，在该方法栈，buf还在引用
        System.gc();
    }

    public void gc2() {
        byte[] buf = new byte[10 * 1024 * 1024];
        buf = null;
        // 执行buf空间回收，对象无引用
        System.gc();
    }

    public void gc3() {
        {
            byte[] buf = new byte[10 * 1024 * 1024];
        }
        // 不执行回收，buf为第二个局部变量
        System.gc();
    }

    public void gc4() {
        {
            byte[] buf = new byte[10 * 1024 * 1024];
        }
        int value = 10;
        // 执行buf空间回收。局部变量slot复用，占用索引为1的局部变量
        System.gc();
    }

    public void gc5() {
        gc1();
        // 执行了buf空间回收，方法栈桢弹出，作用域失效
        System.gc();
    }
}
```

## 二、内存溢出与内存泄漏

### 1. 内存溢出

#### 1) 必须满足的条件

1. 无空闲空间；
2. 垃圾收集器无法提供更多内存。

#### 2) 相关说明

* GC一直在发展，除非占用速度大于回收速度，否则不太容易造成OOM

* 报OOM之前**极大概率会执行**一次**独占式的Full GC**（最后的挣扎）
  * 在引用机制分析后，JVM会尝试回收**软引用**指向对象;
  * java.nio.Bits.reserveMemory()方法，会调用System.gc()。
  * **GC不触发**的例子：分配一个**超过堆大小的对象**，JVM可**直接判断GC无法解决该问题**，直接抛出OOM。

#### 3) 可能原因

1. **堆内存设置太小**。
2. 代码中创建**大量大对象**，并且长时间**不能被垃圾收集器收集**。

### 2. 内存泄漏（Memory Leak）

#### 1) 定义

* 对象不会再被程序使用，GC却无法执行回收。

#### 2) 相关说明

* 不是程序崩溃的直接原因。但会导致**内存逐步被蚕食殆尽**，最终导致OOM。
* **Java的内存泄漏**，存储空间不是物理内存，而是虚拟机内存，取决于磁盘交换区设定的大小。

#### 3) 常见场景

1. 单例设计模式

   生命周期与应用程序一样长。

   举例：Runtime类实例对象

2. 一些提供close的资源未关闭

   * 数据库连接
   * 网络连接
   * io连接

## 三、Stop The World

### 1. 定义

GC事件发生时候，**停止用户线程**，无任何响应。

### 2. 说明

* GC完成后恢复，频繁中断会让用户感觉是网速问题，影响体验，所以**需要减少STW事件发生**。
* 所有GC都有整个事件发生。垃圾回收器越优秀，则STW时间会更短。
* STW是JVM后台自动发起和自动完成的。在用户不可见的情况下挂起用户线程。
* 开发过程中不要用System.gc()，会导致Stop the world。

#### 可达性分析算法场景

* 分析工作必须在一个保证一致性的快照中进行。
* 分析过程若引用关系还在不断变化，分析结果准确性无法保证。

## 四、垃圾回收的并行与并发

### 1. 并发（Concurrent）

#### 1) 概念

一个时段中，在**同一个CPU核心上**运行的几个程序，处于以启动到运行完毕之间。

#### 2) 说明

并不是真正意义上的【同时进行】，只是CPU把一个时间段划分为几个**时间片**，然后在几个时间区间内**来回切换应用程序**，**让用户感觉**多个应用程序**同时进行**。

### 2. 并行（Parallel）

#### 1) 概念

系统有**多个CPU核心**时候，两个进行互不抢占CPU资源，可以同时进行，我们称为并行（Parallel）。

#### 2) 说明

* 决定CPU的因素**不是CPU数**，而是**CPU核心数**，一个多核的CPU也可以并行。
#### 3) 适用场景
* 科学计算、后台处理等**弱交互场景**。

## 五、安全点与安全域

## 六、对象引用关系

### 1. 强引用

### 2. 弱引用

### 3. 软引用

### 4. 虚引用

### 5. 终结器引用