# 17_垃圾回收器

## 一、GC分类与性能指标

* 不同厂商、不同版本的JVM可有自己的实现。
* 不同角度有不同分类。

> Java不同版本的新特性

1. 语法层面：

   Lambda，switch，自动装箱、拆箱、enum、泛型。

2. API层面：Stream API，新的日期时间，Optional，String，集合框架

3. 底层优化：

   JVM的GC变化、元空间、静态域、字符串常量池等。

### 1. 分类

#### 1) 按线程数分

* **串行**垃圾回收器
  * 适用于单核或较小内存等**资源受限的场景**。
* **并行**垃圾回收器
  * 适用于**并发能力较强**的CPU。
  * 并行使得**多个CPU同时执行**，提升了应用的吞吐量。
  * 仍然采用**独占式的STW机制**。

#### 2)按工作模式分

* **并发式**
  * GC线程与用户线程**交替工作**；
  * 尽可能减少用户线程停顿时间。
* **独占式**
  * GC时候**停止用户线程（STW）**。

#### 3)按碎片处理方式

* **压缩式**：执行碎片空间处理。
* **非压缩式**：不执行碎片空间处理。

#### 4) 按工作内存区间

* **年轻代**垃圾回收器
* **老年代**垃圾回收器

### 2. 性能指标

**吞吐量**、**暂停时间**、**内存占用**三者共同构成【**不可能三角**】，尽可能满足其中两项。

目前的标准：在**最大吞吐量优先**的情况下，**降低停顿时间**。

#### 1) **吞吐量（Throughput）**

**用户代码运行时间占比**总运行时间。

![吞吐量与暂停时间](ref/吞吐量与暂停时间.svg)

#### 2) 垃圾收集开销

吞吐量的补数，**GC时间占比**总运行时间。

#### 3) **暂停时间**

用户线程被暂停的时间。

#### 4) 收集频率

相对于应用程序执行，收集操作的发生频率。

#### 5) **内存占用**

Java堆区所占内存的大小。

#### 6) 快速

一个对象从诞生到被回收经历的时间。

## 二、不同垃圾回收器概述

### 1. 发展历史

1. 1999年随**JDK1.3.1**一起来的是**串行方式的serial GC** ，它是第一款GC。ParNew垃圾收集器是serial收集器的多线程版本
2. 2002年2月26日，**JDK1.4.2**，**Parallel GC** 和**Concurrent Mark Sweep GC**一起发布
3. 在**JDK6之后**，**Para1lel Gc**成为**HotSpot默认**GC.
4. 2012年，在**JDK1.7u4**版本中，**G1可用**。
5. 2017年，**JDK9**中**G1变成默认**的GC，以替代CMS。
6. 2018年3月，**JDK10**中**G1 GC**的**并行完整垃圾回收**，实现并行性来改善最坏情况下的延迟。
7. 2018年9月，**JDK11**发布。引入**Epsilon（ε）**垃圾回收器，又被称为**【No-op】（无操作）**回收器。同时，引入**ZGC**:**可伸缩的低延迟**垃圾回收器(Experimental)。
8. 2019年3月，**JDK12**发布。**增强G1** GC，**自动返回未用堆内存给操作系统**。同时，引入**Shenandoah GC**:**低停顿时间的GC** (Experimental)。
9. 2019年9月，**JDK13**发布。**增强ZGC**，自动返回未用堆内存给操作系统。
10. 2020年3月，**JDK14**发布。**删除CMS**垃圾回收器。扩展ZGC在macos和windows
    上的应用

### 2. 垃圾收集器之间的配合关系

![垃圾收集器的关系](ref/垃圾收集器的关系.svg)

* 没有最优秀的垃圾回收器，只能根据使用场景选出最优的组合。

### 查看默认垃圾回收器

1. VM参数

   **-XX:+PrintCommandLineFlags** (查看命令行相关参数，包含使用的垃圾回收器）

2. 使用命令行指令

   **jinfo -flag [相关垃圾回收器参数]  [进程ID]**

## 三、Serial回收器：串行回收

### 1. 年轻代——Serial

1. JDK 1.3之前的唯一选择。
2. Hotspot VM在**Client模式**下，**新生代默认**。
3. 采用**复制算法**、**串行回收**、**STW机制**。

### 2. 老年代——Serial Old

1. **Client模式**下，老年代默认。
2. 采用**标记-压缩算法**、**串行回收**、**STW机制**。
3. **Server模式**下，两个用途：
   * 与**新生代的Parallel Scavenge**配合使用。
   * 作为**CMS的后备方案**。

### 3. 优势

**简单而高效**。对于限定**单CPU环境**来说，**无线程间交互**的开销。

### 4. 使用

VM参数：**-XX:+UseSerialGC**

## 四、ParNew回收器：并行回收

### 1. 概述

1. 是Parallel New缩写，用于**处理新生代**的垃圾回收，是Serial的**多线程版本**（新生代回收频繁，并行方式更高效）。
2. 采用**复制算法**、**STW机制**。
3. 很多JVM在**Server模式**下新生代默认。
4. **适用于多核CPU环境**，充分利用硬件资源提升吞吐量。在单核CPU环境，性能不及Serial。

### 2. 适用

1. VM参数设置启用：
   * **-XX:+UseParNewGC**
2. 限制线程数量：
   * **-XX:ParallelGCThreads**，默认等于CPU线程数

## 五、Parallel 收集器：吞吐量优先

> Java 8中默认组合。

### 1. 年轻代——Parallel Scavenge

1. 采用**复制算法**、**并行回收**、**STW机制**。
2. **可控制的吞吐量**。
   * 适合**后台运算**、**不需要太多交互**的场景。

3. **自适应调节**策略。

### 2. 老年代——Parallel Old

1. JDK 1.6时提出，用于**替换Serial Old**。
2. 采用**标记-压缩算法**、**并行回收**、**STW机制**。

### 3. 参数设置

* **-XX:+UseParallelGC**：手动指定**年轻代**使用Parallel并行收集器。
* **-XX:+UseParallelOldGC**：手动指定**老年代**使用Parallel并行收集器。

以上两个参数是一组，设置一个后，会**互相激活**。



* **-XX:ParallelGCThreads**：设置**年轻代**并行收集器**线程数**。最好与CPU核心数相等，过多线程影响性能。
  * CPU核心数 **≤ 8**——**等于cpu_count**
  * CPU核心数**＞8**—— **3 + (5 \* cpu_count) / 8**
* **-XX:MaxGCPauseMillis**：设置STW最大停顿时间，单位ms。需**谨慎使用**。
  * 为了**尽可能满足（可能会超过）**该限制，JVM工作时会**适当调整堆大小**或**其他参数**。
  * 对**用户**来讲，**停顿时间**越短越好。**服务端**注重**高并发及吞吐量**，所以更适合Parallel进行控制。
* **-XX:GCTimeRatio**：设置**垃圾收集时间占比**总时间。用于衡量吞吐量的大小。
  * 取值范围(0, 100)，默认99。
  * 与上一个参数-XX:MaxGCPauseMillis有一定的矛盾性。

* **-XX:+UseAdaptiveSizePolicy**：设置**Parallel Scavenge的自适应调节策略**。
  * 这种模式下，会自动调整**年轻代大小**、**Eden和Survivor比例**、**老年代晋升年龄**等。来确保堆大小、吞吐量、停顿时间之间的平衡点。
  * 适用于手动调优困难的场合。仅需指定**最大堆内存**、**吞吐量**、**停顿时间**。
  * 默认开启状态。

## 六、CMS回收器：低延迟

### 1. 概述

* **老年代收集器**，无法与Parallel Scavenge配合工作。

* JDK 1.5时，适用于**强交互应用**的并发垃圾收集器**Concurrent-Mark-Sweep**。
* 是Hotspot第一款真正意义上的**并发垃圾收集器**，实现**用户线程**和**垃圾回收线程**的**并发工作**。
* 关注点：缩短**用户线程停顿时间**，达到交互效果。
* 采用**标记-清除算法**，**STW机制**。

### 2. 运行过程

![CMS工作原理](ref/CMS工作原理.svg)

#### 1) 初始标记

* STW机制，**停止所有用户线程**。
* 标记出**GC Roots能直接关联**的对象。
* **速度非常快**。

#### 2) 并发标记

* 从上一步的GC Roots直接关联的对象开始，**遍历整个对象图**。
* **耗时较长**，与用户线程**并发执行**。

#### 3) 重新标记

* **修正**并发标记期间，因为**用户线程继续运作**而导致的**关系变动的一部分对象**。
* 运行时间，**相比初始标记阶段稍长**。

#### 4) 并发清除

* 清理标记对象，释放内存空间。
* 使用**标记-清除（Mark-Sweep）算法**，**无需移动活对象**，所以可以与用户线程**并发执行**。

### 3. 分析

* 最耗时的**并发标记**与**并发清除**阶段，**用户线程不暂停**，整体回收是**低停顿**的。
* 用户线程不中断，要求**用户线程有足够的内存**可用。
* 回收时机：**堆内存**达到一定**阈值**。
* **预留内存不够**，就会出现一次【Concurrent Mode Failure】失败。此时采用备选方案：**临时启用Serial Old**进行老年代GC，停顿时间会更长一些。
* 为什么不用标记-压缩(Mark-Compact)算法？
  * 并发清除，保证**用户线程执行**，不能修改**存活对象的地址**。

#### 1) 优势

* **并发**收集
* **低延迟**

#### 2) 劣势

* **产生内存碎片**。不能修改存活对象的地址。碎片化严重导致**提前触发Full GC**。
* **对CPU资源非常敏感**。并发阶段，不会停顿用户线程，但会导致**应用程序变慢**，**总吞吐量降低**。
* **无法处理浮动垃圾**。【并发标记】阶段仅修正【怀疑是垃圾但不是垃圾】的对象。**该阶段用户线程产生的垃圾**对象不在初始阶段GC Roots中，**【变成垃圾】的对象无法处理**。

### 4. 参数设置

* **-XX:+UseConcMarkSweepGC**
  * 手动**指定CMS**，同时**新生代GC自动绑定为ParNew**（-XX:+UseParNewGC）。
* **-XX:CMSInitiatingOccupanyFraction**
  * 堆内存达到该阈值时，开始执行GC。
  * JDK 1.5默认68，JDK 1.6默认92。
  * 该选项可**有效降低Full GC次数**。
* **-XX:+UseCMSCompactAtFullCollection**
  * **开启**Full GC后，对内存空间进行压缩整理。
* **-XX:CMSFullGCsBeforeCompaction=m**。
  * **Full GC执行m次后**，对内存空间压缩整理。
* **-XX:ParallelCMSThreads=n**
  * 设置CMS线程数。默认 **(ParallelGCThreads + 3) / 4**。

### 5. 小结

* 最小化内存，并行开销，选Serial GC

* 最大化应用程序吞吐量，选Parallel GC

* 最小化GC中断时间，选择CMS GC

## 七、G1回收器：区域化分代式

## 八、垃圾回收器小结

## 九、GC日志分析

## 十、垃圾回收器的新发展